-- 1번 : 조건(외부조인, 교차조인, 셀프조인)

--1) 외부조인 
CREATE TABLE TBL_STUDENT (
	STU_SID NUMBER, 
	STU_NAME VARCHAR2(20),
	STU_MAJOR VARCHAR2(30), 
	CONSTRAINT PK_STUDENT PRIMARY KEY(STU_SID)
);

SELECT * FROM TBL_STUDENT;

--데이터 삽입 

INSERT INTO TBL_STUDENT VALUES(1, '홍길동', '컴퓨터공학');
INSERT INTO TBL_STUDENT VALUES(2, '김영희', '컴퓨터공학');
INSERT INTO TBL_STUDENT VALUES(3, '이철수', '정보보안학');
INSERT INTO TBL_STUDENT VALUES(4, '신호동', '정보보안학');
INSERT INTO TBL_STUDENT VALUES(5, '신호동', '정보보안학');


DROP TABLE TBL_ENROLL;

CREATE TABLE TBL_ENROLL( 
	ENR_SID NUMBER, --학생ID
	ENR_CID NUMBER, --과목ID
	ENR_GRADE CHAR(2), --학점 
	CONSTRAINT PK_ENROLL PRIMARY KEY(ENR_SID, ENR_CID), 
	CONSTRAINT FK_ENROLL FOREIGN KEY(ENR_SID) REFERENCES TBL_STUDENT(STU_SID)
	ON DELETE CASCADE 
	-- ON DELETE CASCADE 옵션은 부모테이블의 행이 삭제될경우 자식 테이블의 관련된 행도 자동 삭제된다 
);

--데이터 삽입 
INSERT INTO TBL_ENROLL VALUES(1, 101, 'A');
INSERT INTO TBL_ENROLL VALUES(2, 102, 'B');
INSERT INTO TBL_ENROLL VALUES(3, 101, 'C');
INSERT INTO TBL_ENROLL VALUES(4, 102, 'A');


--1) 외부조인(OUTER JOING) 
-- LEFT OUTER JOIN 
-- 모든 학생 정보 기준으로 수강 정보가 있는 경우 함께 출력하고 없는 경우 NULL출력 
SELECT STU_SID, STU_NAME, STU_MAJOR, ENR_CID, ENR_GRADE 
FROM TBL_STUDENT S LEFT OUTER JOIN TBL_ENROLL E
ON S.STU_SID = E.ENR_SID; 

-- RIGHT OUTER JOIN 
-- 수강 정보 기준으로 수강한 학생이 없는 경우에도 학생 정보는 NULL로 표시 
SELECT * FROM TBL_ENROLL; 

SELECT * FROM TBL_STUDENT; 

INSERT INTO TBL_ENROLL 
VALUES(6, 103, NULL);

SELECT * FROM TBL_BOOKS;
CREATE TABLE TBL_BP(
	BP_ID NUMBER, 
	BP_PRICE NUMBER, 
	CONSTRAINT PK_BP PRIMARY KEY(BP_ID)
);

SELECT * FROM TBL_BP; 

INSERT INTO TBL_BP  
--VALUES(1, 15000);
--VALUES(2, 23000);
VALUES(10, 45000);

SELECT BOOK_ID, BOOK_TITLE, BOOK_AUTHOR, BP_ID, BP_PRICE  
FROM TBL_BOOKS RIGHT JOIN TBL_BP 
ON BOOK_ID = BP_ID; 

--FULL OUTER JOIN 
SELECT BOOK_ID, BOOK_TITLE, BOOK_AUTHOR, BP_ID, BP_PRICE  
FROM TBL_BOOKS FULL JOIN TBL_BP 
ON BOOK_ID = BP_ID; 

-- 2) 교차조인(CROSS JOIN)  
SELECT BOOK_ID, BOOK_TITLE, BOOK_AUTHOR, BP_ID, BP_PRICE  
FROM TBL_BOOKS CROSS JOIN TBL_BP; 

CREATE TABLE TBL_BOOKS(
	BOOK_ID NUMBER,
	BOOK_TITLE VARCHAR2(100),
	BOOK_AUTHOR VARCHAR2(100),
	CONSTRAINT BOOK_PK PRIMARY KEY(BOOK_ID)
);

INSERT INTO TBL_BOOKS 
--VALUES(1, '위대한 개츠비', 'F.스콧 피츠제럴드');
--VALUES(2, '해리포터와 마법사의 돌', 'J.K. 롤링');
--VALUES(3, '1984', '조지오웰');
--VALUES(4, '오만과 편견', '제인 오스틴');
--VALUES(5, '데미안', '헤르만 헤세');

-- 3) 셀프조인(SELF JOIN) 
-- 직원과 그 매니저의 이름을 함께 출력 
SELECT E.EMPLOYEES_ID 직원ID, E.FIRST_NAME 직원이름, M.EMPLOYEE_ID 매니저ID, M.FIRST_NAME 매니저이름 
FROM EMPLOYEES E LEFT JOIN EMPLOYEES M 
ON M.EMPLOYEE_ID  = E.MANAGER_ID
ORDER BY E.EMPLOYEE_ID;

SELECT * FROM EMPLOYEES;

-- 부하가 없는 직원 찾기 
SELECT E.EMPLOYEE_ID, E.FIRST_NAME
FROM EMPLOYEES E LEFT JOIN EMPLOYEES M
ON M.MANAGER_ID = E.EMPLOYEE_ID
WHERE M.EMPLOYEE_ID IS NULL;

CREATE TABLE TBL_A(
	NAME VARCHAR2(20)
);

INSERT INTO TBL_A VALUES('홍길동');
INSERT INTO TBL_A VALUES('전보라');
INSERT INTO TBL_A VALUES('검나나');
INSERT INTO TBL_A VALUES('김두비');

CREATE TABLE TBL_B (
	NAME VARCHAR2(20)
);

INSERT INTO TBL_B VALUES('이철수'); 
INSERT INTO TBL_B VALUES('심호동'); 
INSERT INTO TBL_B VALUES('이지민'); 
INSERT INTO TBL_B VALUES('이영희'); 


SELECT * FROM TBL_A; 
SELECT * FROM TBL_B; 



-- 1) UNION : 합집합, 중복제거 => 결과는 중복값이 모든 이름 표시 
SELECT NAME FROM TBL_A  
UNION 
SELECT NAME FROM TBL_B;

-- 2) UNION ALL : 합집합, 중복제거X
SELECT NAME FROM TBL_A  
UNION ALL 
SELECT NAME FROM TBL_B;

-- 4) MINUS : 차집합 
SELECT NAME FROM TBL_A  
MINUS 
SELECT NAME FROM TBL_B; 

SELECT NAME FROM TBL_B  
MINUS  
SELECT NAME FROM TBL_A;  



--2. 시퀀스
CREATE TABLE TBL_USERS( 
	USER_ID NUMBER, 
	USER_NAME VARCHAR2(30),
	CONSTRAINT PK_USERS PRIMARY KEY(USER_ID)  
);

CREATE SEQUENCE SEQ_USER_ID START WITH 10 INCREMENT BY 1; 

INSERT INTO TBL_USERS VALUES(SEQ_USER_ID.NEXTVAL, '짱구');
INSERT INTO TBL_USERS VALUES(SEQ_USER_ID.NEXTVAL, '짱구1');
INSERT INTO TBL_USERS VALUES(SEQ_USER_ID.NEXTVAL, '짱구2');
INSERT INTO TBL_USERS VALUES(TO_CHAR(SYSDATE, 'YYYYMMDD') || LPAD(SEQ_USER_ID.NEXTVAL), '짱구2');

SELECT * FROM TBL_USERS;  


DROP SEQUENCE SEQ_USER_ID;
CREATE SEQUENCE SEQ_USER_ID START WITH 1 INCREMENT BY 1 NOCYCLE NOCACHE; 

SELECT SEQ_USER_ID.NEXTVAL 
FROM DUAL;   

SELECT SEQ_USER_ID.CURRVAL 
FROM DUAL; 

--3. VIEW 
CREATE VIEW MEMRENTAL AS
SELECT  M.MEM_ID, M.MEM_NAME, R.REN_ID, R.BOOK_ID, R.REN_RENTALDATE, R.REN_RETURNDATE 
FROM TBL_MEMBER M JOIN TBL_RENTAL R    
ON M.MEM_ID = R.MEM_ID; 

SELECT * FROM MEMRENTAL;

INSERT INTO MEMRENTAL;

INSERT INTO MEMRENTAL 
VALUES(5, '짱아', 1, 1, SYSDATE, SYSDATE); 
--뷰를 통해 데이터를 업데이트 하려면 뷰가 키를 보존하는 테이블과 연결되어 있어야한다 
--뷰가 참조되는 기본 테이블의 각 해잉 뷰에서 정확히 하나의 행에 해당해야한다 

--해결방법1) 직접 테이블에 INSERT 
--해결방법2) INSTEAD OF TRIGGER 사용(트리거를 사용하여 뷰에서 INSERT 가능하도록 하는 방법)


--셀프조인한 결과 테이블을 VIEW로 생성 
CREATE VIEW VIEW_EMPLOYEES AS
SELECT E.EMPLOYEE_ID 직원ID, E.FIRST_NAME 직원이름, M.EMPLOYEE_ID 매니저ID, M.FIRST_NAME 매니저이름
FROM EMPLOYEES E LEFT JOIN EMPLOYEES M
ON M.EMPLOYEE_ID =  E.MANAGER_ID
ORDER BY E.EMPLOYEE_ID;



SELECT * FROM VIEW_EMPLOYEES; 
































